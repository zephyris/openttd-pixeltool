<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>OpenTTD PixelTool</title>
		
		<script type="text/javascript">
//3D image properties
var width=1;
var height=1;
var depth=1;
//...and image data as an array of arrays of arrays in the form [x][y][z]
var pixels=[[[0]]];
//...and symmetry information
var symmetryX=true;
var symmetryY=true;
//...and whether or not to modify just a single pixel or the whole orthogonal stack of pixels
var modifyPixelStack=false;
//...and the current editing tool
currentTool="editPixel"; //Valid values are "editPixel", "pickColor"

//Input canvas properties
var inputX=0;
var inputY=0;
var inputZ=0;

//Palette and colour properties
//Current index...
var index=0;
//...and the lookup palette as an array of [r, g, b] values
var palette=[[0, 0, 255], [16, 16, 16], [32, 32, 32], [48, 48, 48], [64, 64, 64], [80, 80, 80], [100, 100, 100], [116, 116, 116], [132, 132, 132], [148, 148, 148], [168, 168, 168], [184, 184, 184], [200, 200, 200], [216, 216, 216], [232, 232, 232], [252, 252, 252], [52, 60, 72], [68, 76, 92], [88, 96, 112], [108, 116, 132], [132, 140, 152], [156, 160, 172], [176, 184, 196], [204, 208, 220], [48, 44, 4], [64, 60, 12], [80, 76, 20], [96, 92, 28], [120, 120, 64], [148, 148, 100], [176, 176, 132], [204, 204, 168], [72, 44, 4], [88, 60, 20], [104, 80, 44], [124, 104, 72], [152, 132, 92], [184, 160, 120], [212, 188, 148], [244, 220, 176], [64, 0, 4], [88, 4, 16], [112, 16, 32], [136, 32, 52], [160, 56, 76], [188, 84, 108], [204, 104, 124], [220, 132, 144], [236, 156, 164], [252, 188, 192], [252, 208, 0], [252, 232, 60], [252, 252, 128], [76, 40, 0], [96, 60, 8], [116, 88, 28], [136, 116, 56], [156, 136, 80], [176, 156, 108], [196, 180, 136], [68, 24, 0], [96, 44, 4], [128, 68, 8], [156, 96, 16], [184, 120, 24], [212, 156, 32], [232, 184, 16], [252, 212, 0], [252, 248, 128], [252, 252, 192], [32, 4, 0], [64, 20, 8], [84, 28, 16], [108, 44, 28], [128, 56, 40], [148, 72, 56], [168, 92, 76], [184, 108, 88], [196, 128, 108], [212, 148, 128], [8, 52, 0], [16, 64, 0], [32, 80, 4], [48, 96, 4], [64, 112, 12], [84, 132, 20], [104, 148, 28], [128, 168, 44], [28, 52, 24], [44, 68, 32], [60, 88, 48], [80, 104, 60], [104, 124, 76], [128, 148, 92], [152, 176, 108], [180, 204, 124], [16, 52, 24], [32, 72, 44], [56, 96, 72], [76, 116, 88], [96, 136, 108], [120, 164, 136], [152, 192, 168], [184, 220, 200], [32, 24, 0], [56, 28, 0], [72, 40, 4], [88, 52, 12], [104, 64, 24], [124, 84, 44], [140, 108, 64], [160, 128, 88], [76, 40, 16], [96, 52, 24], [116, 68, 40], [136, 84, 56], [164, 96, 64], [184, 112, 80], [204, 128, 96], [212, 148, 112], [224, 168, 128], [236, 188, 148], [80, 28, 4], [100, 40, 20], [120, 56, 40], [140, 76, 64], [160, 100, 96], [184, 136, 136], [36, 40, 68], [48, 52, 84], [64, 64, 100], [80, 80, 116], [100, 100, 136], [132, 132, 164], [172, 172, 192], [212, 212, 224], [40, 20, 112], [64, 44, 144], [88, 64, 172], [104, 76, 196], [120, 88, 224], [140, 104, 252], [160, 136, 252], [188, 168, 252], [0, 24, 108], [0, 36, 132], [0, 52, 160], [0, 72, 184], [0, 96, 212], [24, 120, 220], [56, 144, 232], [88, 168, 240], [128, 196, 252], [188, 224, 252], [16, 64, 96], [24, 80, 108], [40, 96, 120], [52, 112, 132], [80, 140, 160], [116, 172, 192], [156, 204, 220], [204, 240, 252], [172, 52, 52], [212, 52, 52], [252, 52, 52], [252, 100, 88], [252, 144, 124], [252, 184, 160], [252, 216, 200], [252, 244, 236], [72, 20, 112], [92, 44, 140], [112, 68, 168], [140, 100, 196], [168, 136, 224], [200, 176, 248], [208, 184, 255], [232, 208, 252], [60, 0, 0], [92, 0, 0], [128, 0, 0], [160, 0, 0], [196, 0, 0], [224, 0, 0], [252, 0, 0], [252, 80, 0], [252, 108, 0], [252, 136, 0], [252, 164, 0], [252, 192, 0], [252, 220, 0], [252, 252, 0], [204, 136, 8], [228, 144, 4], [252, 156, 0], [252, 176, 48], [252, 196, 100], [252, 216, 152], [8, 24, 88], [12, 36, 104], [20, 52, 124], [28, 68, 140], [40, 92, 164], [56, 120, 188], [72, 152, 216], [100, 172, 224], [92, 156, 52], [108, 176, 64], [124, 200, 76], [144, 224, 92], [224, 244, 252], [200, 236, 248], [180, 220, 236], [132, 188, 216], [88, 152, 172], [244, 0, 244], [245, 0, 245], [246, 0, 246], [247, 0, 247], [248, 0, 248], [249, 0, 249], [250, 0, 250], [251, 0, 251], [252, 0, 252], [253, 0, 253], [254, 0, 254], [255, 0, 255], [76, 24, 8], [108, 44, 24], [144, 72, 52], [176, 108, 84], [210, 146, 126], [252, 60, 0], [252, 84, 0], [252, 104, 0], [252, 124, 0], [252, 148, 0], [252, 172, 0], [252, 196, 0], [64, 0, 0], [255, 0, 0], [48, 48, 0], [64, 64, 0], [80, 80, 0], [255, 255, 0], [32, 68, 112], [36, 72, 116], [40, 76, 120], [44, 80, 124], [48, 84, 128], [72, 100, 144], [100, 132, 168], [216, 244, 252], [96, 128, 164], [68, 96, 140], [255, 255, 255]];
//...and the reindexing to perform to lighten or darken the pixel colour
var lightenArray=[0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 17, 18, 19, 20, 21, 22, 23, 23, 25, 26, 27, 28, 29, 30, 31, 31, 33, 34, 35, 36, 37, 38, 39, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 49, 51, 52, 52, 54, 55, 56, 57, 58, 59, 59, 61, 62, 63, 64, 65, 66, 67, 68, 69, 69, 71, 72, 73, 74, 75, 76, 77, 78, 79, 79, 81, 82, 83, 84, 85, 86, 87, 87, 89, 90, 91, 92, 93, 94, 95, 95, 97, 98, 99, 100, 101, 102, 102, 103, 105, 106, 107, 108, 109, 110, 111, 111, 113, 114, 115, 116, 117, 118, 119, 120, 121, 121, 123, 124, 125, 126, 127, 127, 129, 130, 131, 132, 133, 134, 135, 135, 137, 138, 139, 140, 141, 142, 143, 143, 145, 146, 147, 148, 149, 150, 151, 152, 153, 153, 155, 156, 157, 158, 159, 160, 161, 161, 163, 164, 165, 166, 167, 168, 169, 169, 171, 172, 173, 174, 175, 176, 177, 177, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 191, 193, 194, 195, 196, 197, 197, 199, 200, 201, 202, 203, 204, 205, 205, 207, 208, 209, 209, 211, 212, 213, 214, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
var darkenArray=[0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 16, 17, 18, 19, 20, 21, 22, 24, 24, 25, 26, 27, 28, 29, 30, 32, 32, 33, 34, 35, 36, 37, 38, 40, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 50, 51, 53, 53, 54, 55, 56, 57, 58, 60, 60, 61, 62, 63, 64, 65, 66, 67, 68, 70, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 80, 81, 82, 83, 84, 85, 86, 88, 88, 89, 90, 91, 92, 93, 94, 96, 96, 97, 98, 99, 100, 101, 102, 104, 104, 105, 106, 107, 108, 109, 110, 112, 112, 113, 114, 115, 116, 117, 118, 119, 120, 122, 122, 123, 124, 125, 126, 128, 128, 129, 130, 131, 132, 133, 134, 136, 136, 137, 138, 139, 140, 141, 142, 144, 144, 145, 146, 147, 148, 149, 150, 151, 152, 154, 154, 155, 156, 157, 158, 159, 160, 162, 162, 163, 164, 165, 166, 167, 168, 170, 170, 171, 172, 173, 174, 175, 176, 178, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 192, 192, 193, 194, 195, 196, 198, 198, 199, 200, 201, 202, 203, 204, 206, 206, 207, 208, 210, 210, 211, 212, 213, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
//And the special values of the array
var transparentIndex=0;
var backgroundIndex=255;

//UI properties
//Input display scales...
var uiScale=16;
var uiScalePalette=16;
//...and output display scale
var outDisplayScale=4;
//...the refresh time in miliseconds for the output images
var updateInterval=1000;
//...and whether the left mouse button is currently down
var mouseDown=false;

//Rendering settings
var renderMode="OpenTTDVehicle"; //Valid values are "OpenTTDVehicle", "OpenTTDBuilding"
var shadingZPosition=true;
var shadingAmbient=false;
var shadingShadow=true;
var autoRender=true;

//Initialisation flag
var initialised=false;

//Initialisation
window.onload=function() {
	//Reset the image dimensions
	resetImage();
	//Set the initialised flag to true
	initialised=true;
	//Auto-estimate ui scale
	autoScaleUI();
	//Start the update loop for the output images...
	updateOutputCanvases(outDisplayScale);
	//Update settings to ensure any browser saved changes are reflected
	updateSettings();
	//Update tools GUI to match internal tool state
	setTool(currentTool);
}

window.onresize=autoScaleUI;

function autoScaleUI() {
	scale=Math.max(Math.round(window.innerWidth*(20/100)/20), 4); //Assumes that the palette sidebar is 20% of the screen width, plus a buffer for padding
	//document.getElementById("uiScale").value=scale;
	document.getElementById("uiScalePalette").value=scale;
	updateSettings();
}

//Unloading
window.onbeforeunload=function() {
	return "Warning: This will close/erase your current image.\n(You can save your design by copy/pasting the JSON data.)";	
}

//Update 3D image dimensions
function updateSize(ignore) {
	//Warn users that this will erase their current image
	cont=confirm("Warning: This will erase your current image.\nDo you wish to continue?");
	if (cont==true) {
		//Reset the image if accepted
		resetImage();
	}
}

//Reset 3D image
function resetImage() {
	//Set dimensions from input form
	width=parseInt(document.getElementById("width").value);
	height=parseInt(document.getElementById("height").value);
	depth=parseInt(document.getElementById("depth").value);
	//Loop through pixel values and reset the pixels 3D array
	pixels=[];
	for (var x=0; x<width; x++) {
		pixels[x]=[];
		for (y=0; y<depth; y++) {
			pixels[x][y]=[];
			for (z=0; z<height; z++) {
				pixels[x][y][z]=transparentIndex;
			}
		}
	}
	updatePaletteCanvases();
	updateInputCanvases();
}

function updateSettings() {
	//Set slice selection from input form
	inputX=parseInt(document.getElementById("inputX").value);
	if (inputX>=width) {
		inputX=width-1;
		document.getElementById("inputX").value=inputX;
	}
	inputY=parseInt(document.getElementById("inputY").value);
	if (inputY>=depth) {
		inputY=depth-1;
		document.getElementById("inputY").value=inputY;
	}
	inputZ=parseInt(document.getElementById("inputZ").value);
	if (inputZ>=height) {
		inputZ=height-1;
		document.getElementById("inputZ").value=inputZ;
	}
	//Update symmetry settings
	symmetryX=document.getElementById("xSymmetry").checked;
	symmetryY=document.getElementById("ySymmetry").checked;
	//Update stack vs single pixel modifications
	modifyPixelStack=document.getElementById("modifyPixelStack").checked;
	//Update UI scale
	uiScale=parseInt(document.getElementById("uiScale").value);
	uiScalePalette=parseInt(document.getElementById("uiScalePalette").value);
	//Update output scale
	outDisplayScale=parseInt(document.getElementById("outDisplayScale").value);
	//Update render settings
	shadingZPosition=document.getElementById("shadingZPosition").checked;
	shadingAmbient=document.getElementById("shadingAmbient").checked;
	shadingShadow=document.getElementById("shadingShadow").checked;
	//Update autorender settings, and retrigger drawing if necessary
	if (document.getElementById("autoRender").checked==true && autoRender==false) {
		autoRender=document.getElementById("autoRender").checked;
		updateOutputCanvases(outDisplayScale);
	} else {
		autoRender=document.getElementById("autoRender").checked;
	}

	//Redraw image according to new settings
	updateInputCanvases();
	updatePaletteCanvases();
}

function setTool(toolId) {
	document.getElementById(currentTool).className="button";
	currentTool=toolId;
	document.getElementById(toolId).className="buttonSelected";
} 

function updateInputCanvases(cx, cy, cz) {
	//Grab canvas properties
	var canvasXY=document.getElementById("inputXY");
	var ctxXY=canvasXY.getContext("2d");
	var canvasXZ=document.getElementById("inputXZ");
	var ctxXZ=canvasXZ.getContext("2d");
	var canvasYZ=document.getElementById("inputYZ");
	var ctxYZ=canvasYZ.getContext("2d");

	//If the document is not initialised
	if (initialised==false) {
		//Initialise the global mouse down variable
		mouseDown=false;

		//Add the event listeners for user input
		//Click and/or drag, and global mouse up/down flag
		canvasXY.addEventListener("mousedown", setMouseDownXY, false);
		canvasXY.addEventListener("mouseup", setMouseUp, false);
		canvasXY.addEventListener("mousemove", getPositionXY, false);
		canvasXY.addEventListener("mouseout", setMouseUp, false);

		canvasXZ.addEventListener("mousedown", setMouseDownXZ, false);
		canvasXZ.addEventListener("mouseup", setMouseUp, false);
		canvasXZ.addEventListener("mousemove", getPositionXZ, false);
		canvasXZ.addEventListener("mouseout", setMouseUp, false);

		canvasYZ.addEventListener("mousedown", setMouseDownYZ, false);
		canvasYZ.addEventListener("mouseup", setMouseUp, false);
		canvasYZ.addEventListener("mousemove", getPositionYZ, false);
		canvasYZ.addEventListener("mouseout", setMouseUp, false);

		//Scroll/mouse wheel input
		canvasXY.addEventListener("mousewheel", scrollZ, false);
		canvasXZ.addEventListener("mousewheel", scrollY, false);
		canvasYZ.addEventListener("mousewheel", scrollX, false);
	}

	//Update individual canvases
	//Reset the size
	canvasXY.width=width*uiScale;
	canvasXY.height=depth*uiScale;
	//Loop through pixels in the image
	for (var x=0; x<width; x++) {
		for (var y=0; y<depth; y++) {
			drawPixel(x, y, inputX, inputY, pixels[x][y][inputZ], ctxXY);
		}
	}

	canvasXZ.width=width*uiScale;
	canvasXZ.height=height*uiScale;
	for (var x=0; x<width; x++) {
		for (var z=0; z<height; z++) {
			drawPixel(x, z, inputX, inputZ, pixels[x][inputY][z], ctxXZ);
		}
	}

	canvasYZ.width=depth*uiScale;
	canvasYZ.height=height*uiScale;
	for (var y=0; y<depth; y++) {
		for (var z=0; z<height; z++) {
			drawPixel(y, z, inputY, inputZ, pixels[inputX][y][z], ctxYZ);
		}
	}

	//Helper function for drawing pixel on one of the orthogonal views
	function drawPixel(a, b, inputA, inputB, i, ctx) {
		//Fill the pixel
		ctx.fillStyle="rgba("+palette[i][0]+", "+palette[i][1]+", "+palette[i][2]+", 1)";
		ctx.fillRect(a*uiScale, b*uiScale, uiScale, uiScale);
		//Check if a or b match the selected planes
		if (a==inputA || b==inputB) {
			//And if they do then draw an outline
			ctx.strokeStyle="rgba(255, 0, 255, 1)";
			ctx.lineWidth=1;
			ctx.strokeRect(a*uiScale+0.5, b*uiScale+0.5, uiScale-1, uiScale-1);
		}
	}

	//Handle events
	function setMouseDownXY(event) {
		mouseDown=true;
		getPositionXY(event);
		//Prevent default to prevent the normal text highlighting
		event.preventDefault();
	}
	function setMouseDownXZ(event) {
		mouseDown=true;
		getPositionXZ(event);
		event.preventDefault();
	}
	function setMouseDownYZ(event) {
		mouseDown=true;
		getPositionYZ(event);
		event.preventDefault();
	}

	function setMouseUp(event) {
		mouseDown=false;
	}

	function getPositionXY(event) {
		//Get cursor location
		if (mouseDown==true) {
			xy=getCanvasPosition(event, canvasXY, uiScale);
			//Update pixels data
			setPixels(xy[0], xy[1], inputZ, index, "z");
		}
		//Prevent default to prevent any normal cursor location-dependent events
		event.preventDefault();
	}
	function getPositionXZ(event) {
		if (mouseDown==true) {
			xz=getCanvasPosition(event, canvasXZ, uiScale);
			setPixels(xz[0], inputY, xz[1], index, "y");
		}
		event.preventDefault();
	}
	function getPositionYZ(event) {
		if (mouseDown==true) {
			yz=getCanvasPosition(event, canvasYZ, uiScale);
			setPixels(inputX, yz[0], yz[1], index, "x");
		}
		event.preventDefault();
	}

	//Quick function for setting a set of pixels
	//Includes check for stack modification
	function setPixels(x, y, z, i, d) {
		//Check for which tool to use
		if (currentTool=="editPixel") {
			setPixel(x, y, z, i);
			if (modifyPixelStack==true) {
				if (d=="x") {
					for (x=0; x<width; x++) {
						setPixel(x, y, z, i);
					}
				} else if (d=="y") {
					for (y=0; y<depth; y++) {
						setPixel(x, y, z, i);
					}
				} else if (d=="z") {
					for (z=0; z<height; z++) {
						setPixel(x, y, z, i);
					}
				}
			}
		} else if (currentTool=="pickColour") {
			//Grab the value of the selected pixel, and set the current palette index to match it
			index=pixels[x][y][z];
			updatePaletteCanvases();
		}

		//Quick function for setting a pixel
		//Includes symmetry functions
		function setPixel(x, y, z, i) {
			pixels[x][y][z]=i;
			updatePixel(x, y, z);
			if (symmetryX==true) {
				pixels[width-x-1][y][z]=i;
				updatePixel(width-x-1, y, z);
			}
			if (symmetryY==true) {
				pixels[x][depth-y-1][z]=i;
				updatePixel(x, depth-y-1, z);
			}
			if (symmetryX==true && symmetryY==true) {
				pixels[width-x-1][depth-y-1][z]=i;
				updatePixel(width-x-1, depth-y-1, z);	
			}
		}

		//Function to update a single pixel rather than updating the entire view
		function updatePixel(cx, cy, cz) {
			if (cz==inputZ) {
				drawPixel(cx, cy, inputX, inputY, pixels[cx][cy][inputZ], ctxXY);
			}
			if (cy==inputY) {
				drawPixel(cx, cz, inputX, inputZ, pixels[cx][inputY][cz], ctxXZ);
			}
			if (cx==inputX) {
				drawPixel(cy, cz, inputY, inputZ, pixels[inputX][cy][cz], ctxYZ);
			}
		}
	}

	//Scroll functions to change selected slice on user mouse wheel event
	function scrollZ(event) {
		//Get scroll quantity
		var delta=-Math.max(-1, Math.min(1, event.wheelDelta));
		//Reset the selected slice
		inputZ=Math.max(0, Math.min(height-1, inputZ+delta));
		document.getElementById("inputZ").value=inputZ;
		//And update the image
		updateInputCanvases();
		//Prevent default to prevent the normal scrolling
		event.preventDefault();
	}
	function scrollY(event) {
		var delta=-Math.max(-1, Math.min(1, event.wheelDelta));
		inputY=Math.max(0, Math.min(depth-1, inputY+delta));
		document.getElementById("inputY").value=inputY;
		updateInputCanvases();
		event.preventDefault();
	}
	function scrollX(event) {
		var delta=-Math.max(-1, Math.min(1, event.wheelDelta));
		inputX=Math.max(0, Math.min(width-1, inputX+delta));
		document.getElementById("inputX").value=inputX;
		updateInputCanvases();
		event.preventDefault();
	}
}

function updatePaletteCanvases() {
	//Grab palette canvas properties
	var canvas=document.getElementById("palette");
	var ctx=canvas.getContext("2d");
	//Set the width and height of the palette matrix
	var paletteWidth=16;
	var paletteHeight=Math.floor(palette.length/paletteWidth);
	//Reset the palette canvas width and height
	canvas.width=uiScalePalette*paletteWidth;
	canvas.height=uiScalePalette*paletteHeight;
	//Loop through the palette x, y locations
	for (var x=0; x<paletteWidth; x++) {
		for (var y=0; y<paletteHeight; y++) {
			//...and determine the matching palette index
			var i=x+y*paletteWidth;
			if (palette[i]) {
				//Draw the palette entry
				ctx.fillStyle="rgba("+palette[i][0]+", "+palette[i][1]+", "+palette[i][2]+", 1)";
				ctx.fillRect(x*uiScalePalette, y*uiScalePalette, uiScalePalette, uiScalePalette);
				if (i==index) {
					//And outline it if it is the selected palette index
					ctx.strokeStyle="rgba(255, 0, 255, 1)";
					ctx.lineWidth=1;
					ctx.strokeRect(x*uiScalePalette+0.5, y*uiScalePalette+0.5, uiScalePalette-1, uiScalePalette-1);
				}
			}
		}
	}

	//If the document is not initialised
	if (initialised==false) {
		//Add the event listener for user input
		canvas.addEventListener("mousedown", getPosition, false);
	}
	//Handle events
	function getPosition(event) {
		//Get cursor location
		xy=getCanvasPosition(event, canvas, uiScalePalette);
		//Determine the palette index...
		i=xy[0]+xy[1]*paletteWidth;
		if (i<palette.length) {
			//...and set the selected index to this value if it is valid
			index=i;
			updatePaletteCanvases();
		}
		//Prevent default to prevent any normal cursor events
		event.preventDefault();
	}
}

function updateOutputCanvases() {
	//If the mouse is not currently down (i.e. if the UI does not need to be responsive)
	if (mouseDown==false) {
		//Generate sub-canvases for output
		var canvases=[];
		var ctxs=[];
		for (var j=0; j<8; j++) {
			canvases[j]=document.createElement("canvas");
			ctxs[j]=canvases[j].getContext("2d");
		}

		//Draw the individual canvases
		//Pointing N
		//Flip x
		canvases[0].width=(depth/1.5)*outDisplayScale;	
		canvases[0].height=(width/2+height)*outDisplayScale;
		ctxs[0].fillStyle="rgba("+palette[transparentIndex][0]+", "+palette[transparentIndex][1]+", "+palette[transparentIndex][2]+", 1)";
		ctxs[0].fillRect(0, 0, canvases[0].width, canvases[0].height);
		var shadowVector=[[0, 1, -1], [-1, 1, -1], [1, 1, -1]];
		for (var x=width-1; x>=0; x--) {
			for (var y=0; y<depth; y++) {
				for (var z=0; z<height; z++) {
					i=pixelShader(x, y, z, shadowVector);
					drawPixel(ctxs[0], y/1.5, (width-x-1)/2+z, i);
				}
			}
		}

		//Pointing NE
		//Flip nothing
		canvases[1].width=(depth/2+width/2)*outDisplayScale;	
		canvases[1].height=(width/4+depth/4+height)*outDisplayScale;
		ctxs[1].fillStyle="rgba("+palette[transparentIndex][0]+", "+palette[transparentIndex][1]+", "+palette[transparentIndex][2]+", 1)";
		ctxs[1].fillRect(0, 0, canvases[1].width, canvases[1].height);
		var shadowVector=[[1, 1, -1], [0, 1, -1], [1, 0, -1]];
		for (var x=width-1; x>=0; x--) {
			for (var y=depth-1; y>=0; y--) {
				for (var z=0; z<height; z++) {
					i=pixelShader(x, y, z, shadowVector);
					drawPixel(ctxs[1], x/2+y/2, width/4-x/4+y/4+z, i);
				}
			}
		}

		//Pointing E
		//Flip nothing
		canvases[2].width=(width)*outDisplayScale;	
		canvases[2].height=(depth/4+height)*outDisplayScale;
		ctxs[2].fillStyle="rgba("+palette[transparentIndex][0]+", "+palette[transparentIndex][1]+", "+palette[transparentIndex][2]+", 1)";
		ctxs[2].fillRect(0, 0, canvases[2].width, canvases[2].height);
		var shadowVector=[[1, 0, -1], [1, 1, -1], [1, -1, -1]];
		for (var x=0; x<width; x++) {
			for (var y=0; y<depth; y++) {
				for (var z=0; z<height; z++) {
					i=pixelShader(x, y, z, shadowVector);
					drawPixel(ctxs[2], x, y/4+z, i);
				}
			}
		}

		//Pointing SE
		//Flip y
		canvases[3].width=(depth/2+width/2)*outDisplayScale;	
		canvases[3].height=(width/4+depth/4+height)*outDisplayScale;
		ctxs[3].fillStyle="rgba("+palette[transparentIndex][0]+", "+palette[transparentIndex][1]+", "+palette[transparentIndex][2]+", 1)";
		ctxs[3].fillRect(0, 0, canvases[3].width, canvases[3].height);
		var shadowVector=[[1, -1, -1], [1, 0, -1], [0, -1, -1]];
		for (var x=0; x<width; x++) {
			for (var y=depth-1; y>=0; y--) {
				for (var z=0; z<height; z++) {
					i=pixelShader(x, y, z, shadowVector);
					drawPixel(ctxs[3], x/2+(depth-y-1)/2, depth/4+x/4-(depth-y-1)/4+z, i);
				}
			}
		}

		//Pointing S
		//Flip y
		canvases[4].width=(depth/1.5)*outDisplayScale;	
		canvases[4].height=(width/2+height)*outDisplayScale;
		ctxs[4].fillStyle="rgba("+palette[transparentIndex][0]+", "+palette[transparentIndex][1]+", "+palette[transparentIndex][2]+", 1)";
		ctxs[4].fillRect(0, 0, canvases[4].width, canvases[4].height);
		var shadowVector=[[0, -1, -1], [1, -1, -1], [-1, -1, -1]];
		for (var x=0; x<width; x++) {
			for (var y=0; y<depth; y++) {
				for (var z=0; z<height; z++) {
					i=pixelShader(x, y, z, shadowVector);
					drawPixel(ctxs[4], (depth-y-1)/1.5, x/2+z, i);
				}
			}
		}
	
		//Pointing SW
		//Flip x and y
		canvases[5].width=(depth/2+width/2)*outDisplayScale;	
		canvases[5].height=(width/4+depth/4+height)*outDisplayScale;
		ctxs[5].fillStyle="rgba("+palette[transparentIndex][0]+", "+palette[transparentIndex][1]+", "+palette[transparentIndex][2]+", 1)";
		ctxs[5].fillRect(0, 0, canvases[5].width, canvases[5].height);
		var shadowVector=[[-1, -1, -1], [0, -1, -1], [-1, 0, -1]];
		for (var x=0; x<width; x++) {
			for (var y=0; y<depth; y++) {
				for (var z=0; z<height; z++) {
					i=pixelShader(x, y, z, shadowVector);
					drawPixel(ctxs[5], (width-x-1)/2+(depth-y-1)/2, width/4-(width-x-1)/4+(depth-y-1)/4+z, i);
				}
			}
		}

		//Pointing W
		//Flip x and y
		canvases[6].width=(width)*outDisplayScale;	
		canvases[6].height=(depth/4+height)*outDisplayScale;
		ctxs[6].fillStyle="rgba("+palette[transparentIndex][0]+", "+palette[transparentIndex][1]+", "+palette[transparentIndex][2]+", 1)";
		ctxs[6].fillRect(0, 0, canvases[6].width, canvases[6].height);
		var shadowVector=[[-1, 0, -1], [-1, 1, -1], [-1, -1, -1]];
		for (var x=width-1; x>=0; x--) {
			for (var y=depth-1; y>=0; y--) {
				for (var z=0; z<height; z++) {
					i=pixelShader(x, y, z, shadowVector);
					drawPixel(ctxs[6], (width-x-1), (depth-y-1)/4+z, i);
				}
			}
		}

		//Pointing NW
		//Flip x
		canvases[7].width=(depth/2+width/2)*outDisplayScale;	
		canvases[7].height=(width/4+depth/4+height)*outDisplayScale;
		ctxs[7].fillStyle="rgba("+palette[transparentIndex][0]+", "+palette[transparentIndex][1]+", "+palette[transparentIndex][2]+", 1)";
		ctxs[7].fillRect(0, 0, canvases[7].width, canvases[7].height);
		var shadowVector=[[-1, 1, -1], [-1, 0, -1], [0, 1, -1]];
		for (var x=width-1; x>=0; x--) {
			for (var y=0; y<depth; y++) {
				for (var z=0; z<height; z++) {
					i=pixelShader(x, y, z, shadowVector);
					drawPixel(ctxs[7], (width-x-1)/2+y/2, depth/4+(width-x-1)/4-y/4+z, i);
				}
			}
		}

		//Combine the individual canvases on the main output canvas
		//Setup canvase
		var mainCanvas=document.getElementById("output1");
		var mainCtx=mainCanvas.getContext("2d");
		//Determine dimensions
		if (renderMode=="OpenTTDVehicle") {
			var canvasWidth=0;
			var canvasHeight=0;
			for (var j=0; j<8; j++) {
				canvasWidth+=canvases[j].width+1*outDisplayScale;
				canvasHeight=Math.max(canvasHeight, canvases[j].height);
			}
		} else if (renderMode=="OpenTTDBuilding") {
			var canvasWidth=0;
			var canvasHeight=0;
			for (var j=1; j<8; j+=2) {
				canvasWidth+=canvases[j].width+1*outDisplayScale;
				canvasHeight=Math.max(canvasHeight, canvases[j].height);
			}
		}
		mainCanvas.width=canvasWidth;
		mainCanvas.height=canvasHeight;
		//Set background colour
		mainCtx.fillStyle="rgba("+palette[backgroundIndex][0]+", "+palette[backgroundIndex][1]+", "+palette[backgroundIndex][2]+", 1)";
		mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
		//Draw all the sub-canvases
		var cx=0;
		if (renderMode=="OpenTTDVehicle") {
			for (var j=0; j<8; j++) {
				mainCtx.drawImage(canvases[j], cx, 0);
				cx+=canvases[j].width+1*outDisplayScale;;
			}
		} else if (renderMode=="OpenTTDBuilding") {
			for (var j=1; j<8; j+=2) {
				mainCtx.drawImage(canvases[j], cx, 0);
				cx+=canvases[j].width+1*outDisplayScale;;
			}			
		}
	}

	//Recall function for continual updates
	if (autoRender==true) {
		setTimeout(function() {
			updateOutputCanvases(outDisplayScale);
		}, updateInterval);
	}

	function drawPixel(ctx, x, y, i) {
		//Ignore palette transparent index as transparent
		if (i!=transparentIndex) {
			ctx.fillStyle="rgba("+palette[i][0]+", "+palette[i][1]+", "+palette[i][2]+", 1)";
			ctx.fillRect(Math.round(x)*outDisplayScale, Math.round(y)*outDisplayScale, outDisplayScale, outDisplayScale);
		}
	}

	//Shading function
	//This alters the index of a pixel according to its location or environment
	function pixelShader(x, y, z, shadowVector) {
		var i=pixels[x][y][z];
		if (shadingZPosition==true) {
			i=shaderZPosition(z, i);
		}
		if (shadingAmbient==true) {
			i=shaderAmbient(x, y, z, i);
		}
		if (shadingShadow==true) {
			i=shaderShadow(x, y, z, i, shadowVector);
		}
		return i;
	}

	function shaderZPosition(z, i) {
		if (z>height/2) {
			i=indexDarken(i, Math.round(2*(z-height/2)/(height/2)));
		} else {
			i=indexLighten(i, Math.round(2*(height/2-z-1)/(height/2)));
		}
		return i;
	}

	function shaderAmbient(x, y, z, i) {
		var count=0;
		for (var a=-1; a<2; a++) {
			for (var b=-1; b<2; b++) {
				for (var c=-1; c<2; c++) {
					if (x+a>=0 && x+a<width && y+b>=0 && y+b<depth && z+c>=0 && z+c<height) {
						if (pixels[x+a][y+b][z+c]!=transparentIndex) {
							count++;
						}
					}
				}
			}
		}
		if (count>18) {
			i=indexDarken(i, 1);
		}
		return i;
	}

	function shaderShadow(x, y, z, i, shadowVector) {
		for (var j=0; j<shadowVector.length; j++) {
			if(x+shadowVector[j][0]>=0 && x+shadowVector[j][0]<width && y+shadowVector[j][1]>=0 && y+shadowVector[j][1]<depth && z+shadowVector[j][2]>=0 && z+shadowVector[j][2]<height) {
				if (pixels[x+shadowVector[j][0]][y+shadowVector[j][1]][z+shadowVector[j][2]]!=transparentIndex) {
					i=indexDarken(i, 1);
				} else {
					//i=indexLighten(i, 1);
				}
			}
		}
		return i;
	}

	function indexLighten(i, f) {
		var ni=i;
		for (var j=0; j<f; j++) {
			ni=lightenArray[ni];
		}
		return ni;
	}
	function indexDarken(i, f) {
		var ni=i;
		for (var j=0; j<f; j++) {
			ni=darkenArray[ni];
		}
		return ni;
	}
}

function jsonDataString() {
	var json={};
	json.width=width;
	json.height=height;
	json.depth=depth;
	json.pixels=pixels;
	var jsonString=JSON.stringify(json, null, null);
	return jsonString;
}

function download(filename, text) {
	var pom = document.createElement("a");
	pom.setAttribute("href", "data:text/plain;charset=utf-8,"+encodeURIComponent(text));
	pom.setAttribute("download", filename);
	document.body.appendChild(pom);
	pom.click();
	document.body.removeChild(pom);
}

function downloadRenders(filename, scale) {
	//Record the current display scale as a variable
	var outDisplayScaleTemp=outDisplayScale;
	//Temporarily set the display scale to scale and render the output
	outDisplayScale=scale;
	updateOutputCanvases();
	//Grab the canvas as a data url
	var dataUrl=document.getElementById("output1").toDataURL("image/png");

	//Create and trigger a temporary anchor DOM object to download the image
	var pom = document.createElement("a");
	pom.setAttribute("href", dataUrl);
	pom.setAttribute("download", filename);
	document.body.appendChild(pom);
	pom.click();
	document.body.removeChild(pom);

	//Reset the display scale and redraw the canvas
	outDisplayScale=outDisplayScaleTemp;
	updateOutputCanvases();
}

function loadJsonData() {
	var jsonString=document.getElementById("jsonData").value;
	var json=JSON.parse(jsonString);
	//Warn users that this will erase their current image
	cont=confirm("Warning: This will erase your current image.\nDo you wish to continue?");
	if (cont==true) {
		width=json.width;
		document.getElementById("width").value=width;
		height=json.height;
		document.getElementById("height").value=height;
		depth=json.depth;
		document.getElementById("depth").value=depth;
		resetImage();
		pixels=json.pixels;
	}
	updateInputCanvases();
}

function getCanvasPosition(event, canvas, scale) {
	var rectangle=canvas.getBoundingClientRect();
	x=event.clientX-rectangle.left;
	y=event.clientY-rectangle.top;
	x=Math.floor(x/scale);
	y=Math.floor(y/scale);
	return [x, y];
}

//Voxel data processing functions
//These functions are currently intended for advanced users only, and are only available via console input (e.g. Ctrl+Shift+J under Chrome)
function mirrorVoxels(axis) {
	if (axis=="x") {
		voxelRemapper(function (x) { return width-x-1; }, function (y) { return y; }, function (z) { return z; });
	} else if (axis=="y") {
		voxelRemapper(function (x) { return x; }, function (y) { return depth-y-1; }, function (z) { return z; });
	} else if (axis=="z") {
		voxelRemapper(function (x) { return x; }, function (y) { return y; }, function (z) { return height-z-1; });
	} else {
		voxelRemapper(function (x) { return x; }, function (y) { return y; }, function (z) { return z; });
	}
}

function slideVoxels(axis, distance) {
	if (axis=="x") {
		voxelRemapper(function (x) { return x-distance; }, function (y) { return y; }, function (z) { return z; });
	} else if (axis=="y") {
		voxelRemapper(function (x) { return x; }, function (y) { return y-distance; }, function (z) { return z; });
	} else if (axis=="z") {
		voxelRemapper(function (x) { return x; }, function (y) { return y; }, function (z) { return z-distance; });
	} else {
		voxelRemapper(function (x) { return x; }, function (y) { return y; }, function (z) { return z; });
	}
}

function voxelRemapper(fx, fy, fz) {
	var newpixels=[];
	for (var x=0; x<width; x++) {
		newpixels[x]=[];
		for (y=0; y<depth; y++) {
			newpixels[x][y]=[];
			for (z=0; z<height; z++) {
				if (fx(x)>=0 && fx(x)<width && fy(y)>=0 && fy(y)<depth && fz(z)>=0 && fz(z)<height) {
					newpixels[x][y][z]=pixels[fx(x)][fy(y)][fz(z)];
				} else {
					newpixels[x][y][z]=transparentIndex;
				}
			}
		}
	}
	pixels=newpixels;
	updateInputCanvases();
}

//Advanced loading
//These functions are currently intended for advanced users only, and ar only available via console input (e.g. Ctrl+Shift+J under Chrome)

//Loads the voxel data by merging it with the current view
//Transparent voxels in the loaded data retain their original value, non-transparent voxels gain the new loaded value
function loadAndMergeJsonData() {
	var jsonString=document.getElementById("jsonData").value;
	var json=JSON.parse(jsonString);
	//Only continue if the voxel data dimensions match
	if (width==json.width && height==json.height && depth==json.depth) {
		for (var x=0; x<width; x++) {
			for (y=0; y<depth; y++) {
				for (z=0; z<height; z++) {
					if (json.pixels[x][y][z]!=transparentIndex) {
						pixels[x][y][z]=json.pixels[x][y][z];
					}
				}
			}
		}
	} else {
		alert("Error: Voxel data dimensions did not match, aborting.");
	}
	updateInputCanvases();
}

function scaleVoxels(pow2Scale) {
	scaleUp=true;
	if (pow2Scale<0) {
		scaleUp=false;
		pow2Scale=-pow2Scale;
	}
	for (i=0; i<pow2Scale; i++) {
		newpixels=[];
		if (scaleUp==true) {
			widthNew=width*2;
			depthNew=depth*2;
			heightNew=height*2;
		} else {
			widthNew=width/2;
			depthNew=depth/2;
			heightNew=height/2;
		}
		for (var x=0; x<widthNew; x++) {
			newpixels[x]=[];
			for (y=0; y<depthNew; y++) {
				newpixels[x][y]=[];
				for (z=0; z<heightNew; z++) {
					if (scaleUp==true) {
						newpixels[x][y][z]=pixels[Math.floor(x/2)][Math.floor(y/2)][Math.floor(z/2)];
					} else {
						newpixels[x][y][z]=pixels[x*2][y*2][z*2];
					}
				}
			}
		}
		pixels=newpixels;
		width=widthNew;
		depth=depthNew;
		height=heightNew;
	}
	updateInputCanvases();
}
	
		</script>
		<style media="screen" type="text/css">
body {
	margin: 0px;
	font-size: 100%;
	font-weight: 300;
	font-family: 'Dosis', sans-serif;
	color: rgba(0, 0, 0, 0.70);
}

h1, h2, h3, p {
	margin: 0;
	border: 0;
	padding: 0.0em;
}

input, textarea, label, select {
	margin: 0.1em 0 0 0;
	border: 0;
	padding: 0.2em;

	font-size: inherit;
	font-family: inherit;
	color: inherit;	
}

input, textarea, select {
	box-sizing: content-box;
	border: solid 1px rgba(0, 0, 0, 0.20);
	background-color: rgba(0, 0, 0, 0.02);
}

label {
	width: calc(60% - 0.4em - 2px);
	display: inline-block;
	text-align: right;
}

input, select {
	width: calc(39% - 0.4em - 2px);
	text-align: right;
}

textarea {
	width: calc(99% - 0.4em - 2px);
	height: 4em;
}

input.button {
	border-radius: 3px;
	background-color: rgba(0, 0, 0, 0.2);
	box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
	text-align: center;
}

input.buttonSelected{
	border-radius: 3px;
	background-color: rgba(0, 0, 0, 0.4);
	border: solid 1px rgba(255, 0, 255, 1);
	box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
	text-align: center;
}

input.button:active {
	background-color: rgba(0, 0, 0, 0.3);
	box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}

div {
	margin: 0em;
	border: 0;
	padding: 1em;
}

div.centerContainer {
	margin: 0;
	border: 0;
	padding: 0;
	text-align: center;
}

div.center {
	margin: 0;
	border: 0;
	padding: 0;
	display: inline-block;
	text-align: left;
}

div.noWrapBlocking {
	margin: 0;
	border: 0;
	padding: 0;
	display: inline-block;
	white-space: nowrap;
}

canvas {
	border: 1px;
	border-style: solid;
	border-color: rgba(0, 0, 0, 0.2);

	box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}

div.toolBox {
	position: fixed;
	overflow: auto;

	border: 1px;
	border-style: solid;
	border-color: rgba(0, 0, 0, 0.2);
}

div#title {
	top: 0%;
	left: 20%;
	height: calc(5em - 2em - 2px);
	width: calc(80% - 2em - 2px);
}

div#mainTools {
	top: 0%;
	left: 0%;
	width: calc(20% - 2em - 2px);
	height: calc(100% - 2em - 2px);
}

div#mainCanvas{
	top: calc(0% + 5em);
	left: 20%;
	width: calc(80% - 2em - 2px);
	height: calc(75% - 2em - 2px);
}

div#mainOutput {
	top: calc(75% + 5em);
	left: 20%;
	width: calc(80% - 2em - 2px);
	height: calc(20% - 2em - 2px);
}

@font-face {
	font-family: 'Dosis';
	font-style: normal;
	font-weight: 300;
	src: url(https://fonts.gstatic.com/s/dosis/v32/HhyJU5sn9vOmLxNkIwRSjTVNWLEJabMl2xME.woff2) format('woff2');
	unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
		</style>
	</head>
	<body>
		<div id="title" class="toolBox">
			<h1>OpenTTD PixelTool</h1>
		</div>
		<div id="mainCanvas" class="toolBox">
			<div class="centerContainer">
				<div class="center">
					<div class="noWrapBlocking">
						<div class="noWrapBlocking">
							<h3>Top</h3>
							<canvas id="inputXY" width="512" height="192"></canvas><br>
						</div>
						<div class="noWrapBlocking">
							<form id="mainCanvasForm" onsubmit="return false;">
								<h3>Orthogonal view settings</h3>
								<label for="inputZ">Z slice:</label>
								<input id="inputZ" name="depth" min="0" value="0" step="1" onchange="updateSettings();" type="number"><br>
								<label for="inputY">Y slice:</label>
								<input id="inputY" name="height" min="0" value="0" step="1" onchange="updateSettings();" type="number"><br>
								<label for="inputX">X slice:</label>
								<input id="inputX" name="width" min="0" value="0" step="1" onchange="updateSettings();" type="number"><br>
							</form>
						</div>
					</div><br>
					<div class="noWrapBlocking">
						<div class="noWrapBlocking">
							<h3>Front</h3>
							<canvas id="inputXZ" width="512" height="160"></canvas>
						</div>
						<div class="noWrapBlocking">
							<h3>Side</h3>
							<canvas id="inputYZ" width="192" height="160"></canvas>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div id="mainTools" class="toolBox">
			<h2>Tools</h2>

			<h3>Palette</h3>
			<canvas id="palette" width="208" height="208"></canvas><br>

			<h3>Tools</h3>
			<form id="editTools" onsubmit="return false;">
				<input id="editPixel" type="button" class="buttonSelected" value="Edit Pixel" onclick="setTool(&#39;editPixel&#39;); return false;">
				<input id="pickColour" type="button" class="button" value="Pick Colour" onclick="setTool(&#39;pickColour&#39;); return false;">
			</form>

			<h3>Editing Settings</h3>
			<form id="editOptions" onsubmit="return false;">
				<label for="xSymmetry">X symmetric:</label>
				<input id="xSymmetry" type="checkbox" checked="true" onchange="updateSettings();"><br>
				<label for="ySymmetry">Y symmetric:</label>
				<input id="ySymmetry" type="checkbox" checked="true" onchange="updateSettings();"><br>
				<label for="modifyPixelStack">Modify whole pixel stack:</label>
				<input id="modifyPixelStack" type="checkbox" onchange="updateSettings();"><br>
			</form>

			<h3>Zoom</h3>
			<form id="zoom" onsubmit="return false;">
				<label for="uiScale">Orthogonal view scale:</label>
				<input id="uiScale" type="number" name="width" min="1" value="16" step="1" onchange="updateSettings();">
				<label style="display: hidden;" for="uiScalePalette">Palette scale:</label>
				<input style="display: hidden;" id="uiScalePalette" type="number" name="width" min="1" value="16" step="1" onchange="updateSettings();">
			</form>

			<h3>Save/Load</h3>
			<form id="saveLoadJson" onsubmit="return false;">
				<label for="downloadJson">Download/save image as JSON:</label>
				<input id="downloadJson" type="button" class="button" value="Download" onclick="download(&#39;PixelToolJson.txt&#39;, jsonDataString()); return false;"><br>
				<textarea id="jsonData"></textarea><br>
				<label for="loadJson">Load JSON data:</label>
				<input id="loadJson" type="button" class="button" value="Load" onclick="loadJsonData(); return false;">
			</form>
			<h3>Render settings</h3>
			<form id="renderSettings" onsubmit="return false;">
				<label for="outDisplayScale">Zoom output:</label>
				<input id="outDisplayScale" type="number" name="width" min="1" value="4" step="1" onchange="updateSettings();"><br>
				<label for="autoRender">Automatically update render:</label>
				<input id="autoRender" type="checkbox" onchange="updateSettings();" checked="true"><br>
				<label for="render">Render now:</label>
				<input id="render" type="button" class="button" value="Render" onclick="updateOutputCanvases(); return false;"><br>
				<label for="downloadRender">Download at 1px zoom:</label>
				<input id="downloadRender" type="button" class="button" value="Download" onclick="downloadRenders(&#39;PixelToolPng.png&#39;, 1); return false;"><br>
			</form>
			<h3>3D Shading</h3>
			<form id="shadeSettings3D" onsubmit="return false;">
				<label for="shadingZPosition">Shade by height:</label>
				<input id="shadingZPosition" type="checkbox" onchange="updateSettings();" checked="true"><br>
				<label for="shadingAmbient">Ambient occlusion:</label>
				<input id="shadingAmbient" type="checkbox" onchange="updateSettings();"><br>
				<label for="shadingShadow">Lighting/shadowing:</label>
				<input id="shadingShadow" type="checkbox" onchange="updateSettings();" checked="true"><br>
			</form>
			<h3>New Image</h3>
			<form id="settings" onsubmit="updateSize(); return false;">
				<label for="width">Width:</label>
				<input id="width" type="number" name="width" min="1" value="32" step="1"><br>
				<label for="height">Height:</label>
				<input id="height" type="number" name="height" min="1" value="10" step="1"><br>
				<label for="depth">Depth:</label>
				<input id="depth" type="number" name="depth" min="1" value="12" step="1"><br>
				<label for="sizeSubmit">New image of these dimensions:</label>
				<input id="sizeSubmit" type="button" class="button" value="New" onclick="updateSize(); return false;">
			</form>
		</div>
		<div id="mainOutput" class="toolBox">
			<div class="centerContainer">
				<div class="center">
					<canvas id="output1" width="704" height="104"></canvas>
				</div>
			</div>
		</div>
	
</body></html>